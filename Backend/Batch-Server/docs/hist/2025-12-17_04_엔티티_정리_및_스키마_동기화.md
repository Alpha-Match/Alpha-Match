# Batch Server - 엔티티 정리 및 스키마 동기화

**날짜:** 2025-12-17
**작업 범위:** 불필요한 엔티티 삭제, CheckpointEntity/DlqEntity 수정, 스키마 검증

---

## 배경

### 문제 상황

1. **테이블 명세서와 엔티티 불일치 의심**
   - 사용자 제보: 테이블 명세서와 도메인 엔티티 간 불일치 가능성
   - 검증 필요: DB 스키마 가이드 vs 실제 Entity 클래스

2. **Flyway SQL이 Single Source of Truth**
   - V1__init_database_schema.sql (457 lines)
   - 실제 DB 구조를 정의하는 유일한 소스

3. **Entity 파일들이 과다하게 존재**
   - Candidate 도메인에 예상보다 많은 Entity 파일 발견
   - 실제 DB 테이블과 매칭 필요

---

## 작업 내용

### 1. 전체 테이블 검증 (8개 테이블)

#### 검증 프로세스
1. DB_스키마_가이드.md 읽기 (625 lines)
2. 모든 Entity 파일 읽기 (12개)
3. Flyway V1__init_database_schema.sql 읽기 (457 lines)
4. 테이블별 비교 분석

#### 검증 결과

**✅ 일치하는 테이블 (6개):**
- recruit_metadata ✅
- recruit_embedding ✅
- skill_embedding_dic ✅
- candidate ✅
- candidate_skill ✅
- candidate_skills_embedding ✅

**❌ 불일치하는 테이블 (2개):**
- dlq (컬럼명 불일치)
- checkpoint (PK 구조 완전 불일치)

---

### 2. DlqEntity 수정 (HIGH 우선순위)

#### 발견된 문제

**Flyway SQL (실제 DB):**
```sql
CREATE TABLE dlq (
    id BIGSERIAL NOT NULL,
    domain VARCHAR(50) NOT NULL,
    failed_id UUID,                    -- ✅ 실제 컬럼명
    error_message TEXT NOT NULL,
    payload TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    PRIMARY KEY (id)
);
```

**Entity (수정 전):**
```java
@Column(name = "entity_id", columnDefinition = "UUID")
private UUID entityId;  // ❌ 잘못된 컬럼명
```

**인덱스 (수정 전):**
```java
@Index(name = "idx_dlq_entity_id", columnList = "entity_id")  // ❌ 잘못된 컬럼명
```

#### 수정 사항

**1) DlqEntity.java (line 37-44)**
```java
// ❌ 수정 전
@Column(name = "entity_id", columnDefinition = "UUID")
private UUID entityId;

// ✅ 수정 후
@Column(name = "failed_id", columnDefinition = "UUID")
private UUID failedId;
```

**2) 인덱스 이름 수정 (line 19)**
```java
// ❌ 수정 전
@Index(name = "idx_dlq_entity_id", columnList = "entity_id")

// ✅ 수정 후
@Index(name = "idx_dlq_failed_id", columnList = "failed_id")
```

**3) Static factory method (line 53-60)**
```java
// ✅ 수정 후
public static DlqEntity create(String domain, UUID failedId, String errorMessage, String payloadJson) {
    return DlqEntity.builder()
            .domain(domain)
            .failedId(failedId)  // entityId → failedId
            .errorMessage(errorMessage)
            .payload(payloadJson)
            .build();
}
```

#### 연쇄 수정 (4개 파일)

**1) DlqRepository.java (Domain Interface)**
```java
List<DlqEntity> findByFailedId(UUID failedId);  // findByEntityId → findByFailedId
List<DlqEntity> findByDomainAndFailedId(String domain, UUID failedId);
```

**2) DlqJpaRepository.java (Infrastructure Adapter)**
```java
// JPQL 쿼리 필드명 수정
@Query("SELECT d FROM DlqEntity d WHERE d.domain = :domain AND d.failedId = :failedId")
List<DlqEntity> findByDomainAndFailedId(@Param("domain") String domain, @Param("failedId") UUID failedId);
```

**3) DlqService.java (Use Case Interface)**
```java
DlqEntity saveToDlq(String domain, UUID failedId, String errorMessage, String payloadJson);
List<DlqEntity> findByDomainAndFailedId(String domain, UUID failedId);
```

**4) DlqServiceImpl.java (Use Case Implementation)**
```java
public DlqEntity saveToDlq(String domain, UUID failedId, String errorMessage, String payloadJson) {
    log.warn("[DLQ_SAVE] Domain: {} | Failed ID: {} | Error: {}", domain, failedId, errorMessage);
    DlqEntity dlqEntity = DlqEntity.create(domain, failedId, errorMessage, payloadJson);
    // ...
}
```

#### 영향도
- **심각도:** HIGH (런타임 에러)
- **증상:** Entity 저장 시 `column "entity_id" does not exist` 에러 발생 가능
- **수정 결과:** Flyway SQL과 완전 일치 ✅

---

### 3. CheckpointEntity 수정 (CRITICAL 우선순위)

#### 발견된 문제

**Flyway SQL (실제 DB):**
```sql
CREATE TABLE checkpoint (
    id BIGSERIAL NOT NULL,             -- ✅ id가 PK
    domain VARCHAR(50) NOT NULL UNIQUE, -- ✅ domain은 UNIQUE (PK 아님)
    last_processed_uuid UUID,
    processed_count BIGINT NOT NULL DEFAULT 0, -- ✅ processed_count 포함
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    PRIMARY KEY (id)
);
```

**Entity (수정 전):**
```java
@Id
@Column(name = "domain", length = 50, nullable = false)
private String domain;  // ❌ domain이 PK (잘못됨)

@Column(name = "last_processed_uuid", columnDefinition = "UUID")
private UUID lastProcessedUuid;

@UpdateTimestamp
@Column(name = "updated_at", nullable = false)
private LocalDateTime updatedAt;

// ❌ id 필드 없음
// ❌ processed_count 필드 없음
```

#### 수정 사항

**1) 완전 재작성 (line 26-47)**
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id")
private Long id;  // ✅ NEW: PK (자동 증가)

@Column(name = "domain", length = 50, nullable = false, unique = true)
private String domain;  // ✅ CHANGED: UNIQUE (not PK)

@Column(name = "last_processed_uuid", columnDefinition = "UUID")
private UUID lastProcessedUuid;

@Column(name = "processed_count", nullable = false)
@Builder.Default
private Long processedCount = 0L;  // ✅ NEW: 처리된 레코드 수

@UpdateTimestamp
@Column(name = "updated_at", nullable = false)
private LocalDateTime updatedAt;
```

**2) 메서드 추가/수정**
```java
// ✅ NEW: UUID + 처리 개수 동시 업데이트
public void updateCheckpoint(UUID uuid, long count) {
    this.lastProcessedUuid = uuid;
    this.processedCount = count;
}

// ✅ UPDATED: UUID만 업데이트 (processed_count 증가)
public void updateCheckpoint(UUID uuid) {
    this.lastProcessedUuid = uuid;
    this.processedCount++;
}

// ✅ NEW: 처리 개수 증가
public void incrementProcessedCount() {
    this.processedCount++;
}
```

**3) Static factory method 수정**
```java
public static CheckpointEntity forDomain(String domain) {
    return CheckpointEntity.builder()
            .domain(domain)
            .lastProcessedUuid(null)
            .processedCount(0L)  // ✅ NEW
            .build();
}
```

#### 영향도
- **심각도:** CRITICAL (Entity 구조 완전 불일치)
- **증상:**
  - Entity 저장 시 `column "domain" is not primary key` 에러
  - `id` 컬럼 누락으로 레코드 식별 불가
  - `processed_count` 누락으로 통계 기능 동작 불가
- **수정 결과:** Flyway SQL과 완전 일치 ✅

---

### 4. 불필요한 Candidate Entity 파일 삭제 (6개)

#### 발견 경위

**사용자 질문:**
> "CandidateEmbeddingEntity.java와 CandidateMetadataEntity.java가 필요한가요?"

#### 검증 결과

**Flyway SQL (실제 DB):**
```sql
-- ✅ 실제 존재하는 Candidate 테이블
CREATE TABLE candidate (...)                    -- CandidateEntity.java
CREATE TABLE candidate_skill (...)              -- CandidateSkillEntity.java
CREATE TABLE candidate_skills_embedding (...)   -- CandidateSkillsEmbeddingEntity.java
CREATE TABLE skill_embedding_dic (...)          -- SkillEmbeddingDicEntity.java

-- ❌ 존재하지 않는 테이블
-- candidate_metadata 테이블 없음!
-- candidate_embedding 테이블 없음!
```

**Entity 파일 현황 (삭제 전):**
```
domain/candidate/entity/
├── CandidateEntity.java                 ✅ 필요 (candidate 테이블)
├── CandidateSkillEntity.java            ✅ 필요 (candidate_skill 테이블)
├── CandidateSkillId.java                ✅ 필요 (Composite PK)
├── CandidateSkillsEmbeddingEntity.java  ✅ 필요 (candidate_skills_embedding 테이블)
├── CandidateEmbeddingEntity.java        ❌ 불필요 (candidate_embedding 테이블 없음)
└── CandidateMetadataEntity.java         ❌ 불필요 (candidate_metadata 테이블 없음)
```

#### 삭제 대상 파일 (총 6개)

**1) Entity (2개)**
- CandidateEmbeddingEntity.java
- CandidateMetadataEntity.java

**2) Domain Repository (2개)**
- CandidateEmbeddingRepository.java
- CandidateMetadataRepository.java

**3) Infrastructure JpaRepository (2개)**
- CandidateEmbeddingJpaRepository.java
- CandidateMetadataJpaRepository.java

#### 삭제 실행

```bash
rm -f \
  src/main/java/com/alpha/backend/domain/candidate/entity/CandidateEmbeddingEntity.java \
  src/main/java/com/alpha/backend/domain/candidate/entity/CandidateMetadataEntity.java \
  src/main/java/com/alpha/backend/domain/candidate/repository/CandidateEmbeddingRepository.java \
  src/main/java/com/alpha/backend/domain/candidate/repository/CandidateMetadataRepository.java \
  src/main/java/com/alpha/backend/infrastructure/persistence/CandidateEmbeddingJpaRepository.java \
  src/main/java/com/alpha/backend/infrastructure/persistence/CandidateMetadataJpaRepository.java
```

#### 삭제 이유

1. **잘못된 설계 패턴 적용**
   - Recruit 도메인 패턴(`recruit_metadata` + `recruit_embedding`)을 그대로 따라함
   - Candidate는 DDD Aggregate 패턴 (4개 테이블 분산 구조)

2. **Flyway SQL에 해당 테이블 없음**
   - `candidate_metadata` 테이블 정의 없음
   - `candidate_embedding` 테이블 정의 없음

3. **실제로는 다른 구조 사용**
   - `candidate` 테이블 (metadata 역할)
   - `candidate_skills_embedding` 테이블 (embedding 역할, 768d)

#### 최종 Candidate 도메인 구조 (정확)

**✅ Entity (4개):**
```
CandidateEntity.java                 → candidate
CandidateSkillEntity.java            → candidate_skill (Composite PK)
CandidateSkillId.java                → Composite PK 클래스
CandidateSkillsEmbeddingEntity.java  → candidate_skills_embedding (768d)
```

**✅ Repository (6개):**
```
Domain Layer (Port):
- CandidateRepository.java
- CandidateSkillRepository.java
- CandidateSkillsEmbeddingRepository.java

Infrastructure Layer (Adapter):
- CandidateJpaRepository.java
- CandidateSkillJpaRepository.java
- CandidateSkillsEmbeddingJpaRepository.java
```

---

## 기술 결정 사항

### 1. Flyway SQL이 Single Source of Truth

**원칙:**
```
Flyway SQL (실제 DB 구조)
    ↓
Entity (DB 구조 반영)
    ↓
DB 스키마 가이드 (문서화)
```

**이유:**
- Flyway 마이그레이션은 실제 DB에 적용되는 유일한 소스
- Entity는 Flyway SQL을 따라야 함
- 문서는 Flyway SQL을 참조해야 함

### 2. Entity 필드는 컴파일 타임 상수 사용

**질문 (사용자):**
> "CandidateSkillsEmbeddingEntity의 VECTOR_DIMENSION을 application.yml에서 동적으로 설정할 수 있나요?"

**답변:**
- ❌ 불가능하며, **그럴 필요도 없음**

**이유:**
1. **`public static final`은 컴파일 타임 상수**
   ```java
   public static final int VECTOR_DIMENSION = 768;  // 컴파일 시 결정
   ```
   - Spring의 `@Value`나 `@ConfigurationProperties`로 주입 불가
   - 클래스 로딩 시점에 고정됨

2. **Vector 차원은 DB 스키마에 고정됨**
   ```sql
   CREATE TABLE candidate_skills_embedding (
       skills_vector VECTOR(768) NOT NULL  -- 768차원으로 고정
   );
   ```
   - Flyway 마이그레이션으로 이미 결정됨
   - 런타임에 변경할 수 없음

3. **`application.yml`의 `vector-dimension`은 검증용**
   ```yaml
   candidate:
     vector-dimension: 768  # Entity와 일치하는지 검증만 함
   ```
   - 실제로 차원을 변경하는 용도가 아님
   - BatchProperties에서 읽어서 Entity의 `VECTOR_DIMENSION`과 일치하는지 검증

**만약 차원을 변경하려면:**
1. Flyway 마이그레이션 작성 (예: V6__update_vector_dimension.sql)
2. Entity의 `VECTOR_DIMENSION` 상수 변경
3. `application.yml`의 `vector-dimension` 업데이트
4. 재배포

→ **런타임에 동적 변경은 불가능하며, 그럴 필요도 없음**

### 3. DB 스키마 가이드는 Flyway SQL 기준으로 작성

**발견된 문제:**
- DB_스키마_가이드.md의 checkpoint 테이블 상세 (line 342-345)가 outdated
- ERD 다이어그램은 정확하나, 테이블 상세 명세가 틀림

**해결 방법:**
- Flyway SQL을 기준으로 문서 수정
- ERD가 정확하므로 테이블 상세 명세만 수정

---

## 문제 해결

### 문제 1: Entity와 Flyway SQL 불일치로 런타임 에러 위험

**증상:**
- DLQ 저장 시 `column "entity_id" does not exist` 에러 가능
- Checkpoint 저장 시 `column "domain" is not primary key` 에러 가능

**원인:**
- Entity가 Flyway SQL과 다른 구조로 작성됨
- 초기 설계와 실제 구현 간 괴리

**해결:**
1. Flyway SQL을 기준으로 Entity 완전 재작성
2. DlqEntity: `entityId` → `failedId` 변경
3. CheckpointEntity: PK 구조 + `processed_count` 추가

### 문제 2: 불필요한 Entity 파일로 인한 혼란

**증상:**
- Candidate 도메인에 예상보다 많은 Entity 파일 존재
- 실제 DB 테이블과 매칭되지 않음

**원인:**
- Recruit 도메인 패턴을 잘못 따라한 것으로 추정
- Candidate는 DDD Aggregate 패턴이므로 다른 구조

**해결:**
1. Flyway SQL 기준으로 실제 존재하는 테이블만 확인
2. 존재하지 않는 테이블의 Entity/Repository 6개 삭제

---

## 고정 문서 반영 사항

### CLAUDE.md
- "최근 업데이트" 섹션에 2025-12-17 작업 추가
- Entity 정리 내역 반영

### DB_스키마_가이드.md (선택)
- checkpoint 테이블 상세 수정 (line 342-345)
- ERD는 정확하므로 테이블 상세만 업데이트

---

## 결과

### 수정된 Entity (2개)
- ✅ **DlqEntity.java** - `entityId` → `failedId` (5개 파일 연쇄 수정)
- ✅ **CheckpointEntity.java** - PK 구조 변경, `processed_count` 추가

### 삭제된 파일 (6개)
- ❌ CandidateEmbeddingEntity.java
- ❌ CandidateMetadataEntity.java
- ❌ CandidateEmbeddingRepository.java
- ❌ CandidateMetadataRepository.java
- ❌ CandidateEmbeddingJpaRepository.java
- ❌ CandidateMetadataJpaRepository.java

### 검증 결과
- **총 8개 테이블 검증**
- **8개 테이블 모두 Flyway SQL과 일치** ✅

### 최종 Candidate 도메인 구조
```
Entity (4개):
- CandidateEntity.java (candidate 테이블)
- CandidateSkillEntity.java (candidate_skill 테이블, Composite PK)
- CandidateSkillId.java (Composite PK 클래스)
- CandidateSkillsEmbeddingEntity.java (candidate_skills_embedding 테이블, 768d)

Repository (6개):
- Domain: CandidateRepository, CandidateSkillRepository, CandidateSkillsEmbeddingRepository
- Infrastructure: CandidateJpaRepository, CandidateSkillJpaRepository, CandidateSkillsEmbeddingJpaRepository
```

### 향후 작업
- DB_스키마_가이드.md checkpoint 테이블 상세 수정 (선택)
- DLQ Proposal A 구현 (Processor DLQ 추가)

---

**작업 완료일:** 2025-12-17
**다음 작업:** DLQ Proposal A 구현
