# 도메인 확장 가이드

**작성일**: 2025-12-12
**대상**: Batch-Server
**목적**: 새 도메인 추가 시 체크리스트 및 절차

---

## 개요

Alpha-Match 프로젝트에 새 도메인을 추가하는 방법을 설명합니다. 현재 `recruit`, `candidate` 도메인이 구현되어 있으며, 동일한 패턴으로 확장 가능합니다.

### 도메인 추가 예시

이 가이드에서는 `company` 도메인을 추가하는 예시로 설명합니다.

---

## 1. 요구사항 정의

### 1.1 도메인 정보

| 항목 | 내용 |
|------|------|
| 도메인명 | company |
| 설명 | 회사 정보 |
| Vector 차원 | 512 |
| 주요 속성 | name, industry, employee_count, location |

### 1.2 테이블 설계

**company_metadata:**
- id (UUID, PK)
- name (VARCHAR)
- industry (VARCHAR)
- employee_count (INTEGER)
- location (VARCHAR)
- created_at (TIMESTAMP)
- updated_at (TIMESTAMP)

**company_embedding:**
- id (UUID, PK/FK)
- vector (VECTOR(512))
- updated_at (TIMESTAMP)

---

## 2. Flyway 마이그레이션 작성

### 2.1 도메인 스키마 추가

**파일**: `V6__add_company_schema.sql`

```sql
-- V6: Company 도메인 스키마 추가
-- 작성일: YYYY-MM-DD
-- 목적: 회사 정보 도메인 추가

-- 1. Company Metadata 테이블
CREATE TABLE company_metadata (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    industry VARCHAR(100),
    employee_count INTEGER CHECK(employee_count >= 0),
    location VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 2. Company Embedding 테이블 (512차원)
CREATE TABLE company_embedding (
    id UUID PRIMARY KEY REFERENCES company_metadata(id) ON DELETE CASCADE,
    vector VECTOR(512) NOT NULL,
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 3. 인덱스 생성
CREATE INDEX idx_company_metadata_updated_at ON company_metadata(updated_at);
CREATE INDEX idx_company_metadata_name ON company_metadata(name);
CREATE INDEX idx_company_metadata_industry ON company_metadata(industry);

-- pgvector IVFFlat 인덱스
CREATE INDEX company_embedding_ivfflat
ON company_embedding USING ivfflat (vector vector_l2_ops)
WITH (lists = 100);

-- 4. 트리거 생성 (updated_at 자동 갱신)
CREATE TRIGGER trigger_company_metadata_updated_at
BEFORE UPDATE ON company_metadata
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_company_embedding_updated_at
BEFORE UPDATE ON company_embedding
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- 5. 통계 정보 갱신
ANALYZE company_metadata;
ANALYZE company_embedding;
```

### 2.2 공통 테이블 업데이트

**파일**: `V7__add_company_domain_support.sql`

```sql
-- V7: Company 도메인 지원 추가
-- 작성일: YYYY-MM-DD
-- 목적: DLQ, Checkpoint에 company 도메인 추가

-- 1. DLQ 제약조건 업데이트
ALTER TABLE dlq DROP CONSTRAINT IF EXISTS chk_dlq_domain;
ALTER TABLE dlq ADD CONSTRAINT chk_dlq_domain
CHECK (domain IN ('recruit', 'candidate', 'company'));

-- 2. Checkpoint 제약조건 업데이트
ALTER TABLE checkpoint DROP CONSTRAINT IF EXISTS chk_checkpoint_domain;
ALTER TABLE checkpoint ADD CONSTRAINT chk_checkpoint_domain
CHECK (domain IN ('recruit', 'candidate', 'company'));

-- 3. Checkpoint 초기 레코드
INSERT INTO checkpoint (domain, last_processed_uuid, updated_at)
VALUES ('company', NULL, NOW())
ON CONFLICT (domain) DO NOTHING;

-- 4. 헬퍼 함수 업데이트 (get_domain_stats)
CREATE OR REPLACE FUNCTION get_domain_stats(domain_name VARCHAR)
RETURNS TABLE(
    metadata_count BIGINT,
    embedding_count BIGINT,
    dlq_count BIGINT,
    last_processed_uuid UUID,
    last_checkpoint_time TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        CASE
            WHEN domain_name = 'recruit' THEN (SELECT COUNT(*) FROM recruit_metadata)
            WHEN domain_name = 'candidate' THEN (SELECT COUNT(*) FROM candidate_metadata)
            WHEN domain_name = 'company' THEN (SELECT COUNT(*) FROM company_metadata)
            ELSE 0
        END AS metadata_count,
        CASE
            WHEN domain_name = 'recruit' THEN (SELECT COUNT(*) FROM recruit_embedding)
            WHEN domain_name = 'candidate' THEN (SELECT COUNT(*) FROM candidate_embedding)
            WHEN domain_name = 'company' THEN (SELECT COUNT(*) FROM company_embedding)
            ELSE 0
        END AS embedding_count,
        (SELECT COUNT(*) FROM dlq WHERE domain = domain_name) AS dlq_count,
        (SELECT last_processed_uuid FROM checkpoint WHERE domain = domain_name) AS last_processed_uuid,
        (SELECT updated_at FROM checkpoint WHERE domain = domain_name) AS last_checkpoint_time;
END;
$$ LANGUAGE plpgsql;

-- 5. 통계 뷰 업데이트 (v_all_domain_stats)
CREATE OR REPLACE VIEW v_all_domain_stats AS
SELECT
    'recruit' AS domain,
    (SELECT COUNT(*) FROM recruit_metadata) AS metadata_count,
    (SELECT COUNT(*) FROM recruit_embedding) AS embedding_count,
    (SELECT COUNT(*) FROM dlq WHERE domain = 'recruit') AS dlq_count,
    (SELECT last_processed_uuid FROM checkpoint WHERE domain = 'recruit') AS last_processed_uuid,
    (SELECT updated_at FROM checkpoint WHERE domain = 'recruit') AS last_checkpoint_time
UNION ALL
SELECT
    'candidate' AS domain,
    (SELECT COUNT(*) FROM candidate_metadata) AS metadata_count,
    (SELECT COUNT(*) FROM candidate_embedding) AS embedding_count,
    (SELECT COUNT(*) FROM dlq WHERE domain = 'candidate') AS dlq_count,
    (SELECT last_processed_uuid FROM checkpoint WHERE domain = 'candidate') AS last_processed_uuid,
    (SELECT updated_at FROM checkpoint WHERE domain = 'candidate') AS last_checkpoint_time
UNION ALL
SELECT
    'company' AS domain,
    (SELECT COUNT(*) FROM company_metadata) AS metadata_count,
    (SELECT COUNT(*) FROM company_embedding) AS embedding_count,
    (SELECT COUNT(*) FROM dlq WHERE domain = 'company') AS dlq_count,
    (SELECT last_processed_uuid FROM checkpoint WHERE domain = 'company') AS last_processed_uuid,
    (SELECT updated_at FROM checkpoint WHERE domain = 'company') AS last_checkpoint_time;
```

---

## 3. Entity 클래스 작성

### 3.1 디렉토리 구조

```
src/main/java/com/alpha/backend/domain/company/
├── CompanyMetadataEntity.java
├── CompanyEmbeddingEntity.java
├── CompanyMetadataRepository.java
└── CompanyEmbeddingRepository.java
```

### 3.2 Metadata Entity

**파일**: `CompanyMetadataEntity.java`

```java
package com.alpha.backend.domain.company;

import com.alpha.backend.domain.common.BaseMetadataEntity;
import jakarta.persistence.*;
import lombok.*;

import java.util.UUID;

@Entity
@Table(name = "company_metadata")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CompanyMetadataEntity extends BaseMetadataEntity {

    @Column(name = "name", nullable = false, length = 255)
    private String name;

    @Column(name = "industry", length = 100)
    private String industry;

    @Column(name = "employee_count")
    private Integer employeeCount;

    @Column(name = "location", length = 255)
    private String location;

    @Override
    public String getDomainType() {
        return "company";
    }

    public static class CompanyMetadataEntityBuilder {
        public CompanyMetadataEntityBuilder id(UUID id) {
            CompanyMetadataEntity entity = new CompanyMetadataEntity();
            entity.setId(id);
            return this;
        }
    }
}
```

### 3.3 Embedding Entity

**파일**: `CompanyEmbeddingEntity.java`

```java
package com.alpha.backend.domain.company;

import com.alpha.backend.domain.common.BaseEmbeddingEntity;
import com.pgvector.PGvector;
import jakarta.persistence.*;
import lombok.*;

import java.util.UUID;

@Entity
@Table(name = "company_embedding")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CompanyEmbeddingEntity extends BaseEmbeddingEntity {

    public static final int VECTOR_DIMENSION = 512;

    @Override
    public String getDomainType() {
        return "company";
    }

    @Override
    public int getVectorDimension() {
        return VECTOR_DIMENSION;
    }

    public static CompanyEmbeddingEntity fromFloatArray(UUID id, float[] vectorArray) {
        if (vectorArray.length != VECTOR_DIMENSION) {
            throw new IllegalArgumentException(
                    String.format("Vector dimension mismatch: expected %d, got %d",
                            VECTOR_DIMENSION, vectorArray.length)
            );
        }

        CompanyEmbeddingEntity entity = new CompanyEmbeddingEntity();
        entity.setId(id);
        entity.setVector(new PGvector(vectorArray));
        return entity;
    }
}
```

---

## 4. Repository 작성

### 4.1 Metadata Repository

**파일**: `CompanyMetadataRepository.java`

```java
package com.alpha.backend.domain.company;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

public interface CompanyMetadataRepository extends JpaRepository<CompanyMetadataEntity, UUID> {

    /**
     * Upsert (Bulk)
     */
    @Modifying
    @Query(value = """
        INSERT INTO company_metadata (id, name, industry, employee_count, location, created_at, updated_at)
        VALUES (:id, :name, :industry, :employeeCount, :location, :createdAt, :updatedAt)
        ON CONFLICT (id) DO UPDATE SET
            name = EXCLUDED.name,
            industry = EXCLUDED.industry,
            employee_count = EXCLUDED.employee_count,
            location = EXCLUDED.location,
            updated_at = EXCLUDED.updated_at
        """, nativeQuery = true)
    void upsert(
            @Param("id") UUID id,
            @Param("name") String name,
            @Param("industry") String industry,
            @Param("employeeCount") Integer employeeCount,
            @Param("location") String location,
            @Param("createdAt") LocalDateTime createdAt,
            @Param("updatedAt") LocalDateTime updatedAt
    );

    /**
     * Batch Upsert
     */
    default void upsertAll(List<CompanyMetadataEntity> entities) {
        for (CompanyMetadataEntity entity : entities) {
            upsert(
                    entity.getId(),
                    entity.getName(),
                    entity.getIndustry(),
                    entity.getEmployeeCount(),
                    entity.getLocation(),
                    entity.getCreatedAt(),
                    entity.getUpdatedAt()
            );
        }
    }
}
```

### 4.2 Embedding Repository

**파일**: `CompanyEmbeddingRepository.java`

```java
package com.alpha.backend.domain.company;

import com.pgvector.PGvector;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

public interface CompanyEmbeddingRepository extends JpaRepository<CompanyEmbeddingEntity, UUID> {

    /**
     * Upsert (Bulk)
     */
    @Modifying
    @Query(value = """
        INSERT INTO company_embedding (id, vector, updated_at)
        VALUES (:id, :vector, :updatedAt)
        ON CONFLICT (id) DO UPDATE SET
            vector = EXCLUDED.vector,
            updated_at = EXCLUDED.updated_at
        """, nativeQuery = true)
    void upsert(
            @Param("id") UUID id,
            @Param("vector") PGvector vector,
            @Param("updatedAt") LocalDateTime updatedAt
    );

    /**
     * Batch Upsert
     */
    default void upsertAll(List<CompanyEmbeddingEntity> entities) {
        for (CompanyEmbeddingEntity entity : entities) {
            upsert(entity.getId(), entity.getVector(), entity.getUpdatedAt());
        }
    }
}
```

---

## 5. 서비스 레이어 작성

### 5.1 ChunkProcessor 구현

**ChunkProcessorInterface를 구현하여 Factory 패턴에 자동 등록:**

**파일**: `CompanyChunkProcessor.java`

```java
package com.alpha.backend.application;

import com.alpha.backend.application.service.DlqService;
import com.alpha.backend.config.BatchProperties;
import com.alpha.backend.domain.embedding.company.CompanyEmbeddingEntity;
import com.alpha.backend.domain.embedding.company.CompanyEmbeddingRepository;
import com.alpha.backend.domain.metadata.company.CompanyMetadataEntity;
import com.alpha.backend.domain.metadata.company.CompanyMetadataRepository;
import com.alpha.backend.grpc.CompanyRow;
import com.alpha.backend.grpc.RowChunk;
import com.fasterxml.jackson.databind.json.JsonMapper;
import com.pgvector.PGvector;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Company Chunk Processor
 * ChunkProcessorInterface를 구현하여 Factory에 자동 등록됩니다.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class CompanyChunkProcessor implements ChunkProcessorInterface {

    private static final String DOMAIN = "company";

    private final CompanyMetadataRepository metadataRepository;
    private final CompanyEmbeddingRepository embeddingRepository;
    private final DlqService dlqService;
    private final BatchProperties batchProperties;
    private final JsonMapper jsonMapper;

    @Override
    public String getDomain() {
        return DOMAIN;
    }

    @Override
    @Transactional
    public ChunkProcessingResult processChunk(RowChunk chunk) {
        long startTime = System.currentTimeMillis();
        String threadName = Thread.currentThread().toString();
        int chunkSize = chunk.getRowsCount();

        log.info("=== Company Chunk Processing Started ===");
        log.info("Thread: {} | Chunk Size: {}", threadName, chunkSize);

        if (chunkSize == 0) {
            log.warn("Empty chunk received");
            return new ChunkProcessingResult(0, 0, 0, null, null);
        }

        int successCount = 0;
        int failureCount = 0;
        UUID lastSuccessUuid = null;

        List<CompanyMetadataEntity> metadataList = new ArrayList<>(chunkSize);
        List<CompanyEmbeddingEntity> embeddingList = new ArrayList<>(chunkSize);

        // 1. 개별 row 처리 (실패 시 DLQ 저장)
        for (CompanyRow row : chunk.getRowsList()) {
            try {
                UUID id = UUID.fromString(row.getId());

                // Metadata Entity 생성
                CompanyMetadataEntity metadata = new CompanyMetadataEntity();
                metadata.setId(id);
                metadata.setName(row.getName());
                metadata.setIndustry(row.getIndustry());
                metadata.setEmployeeCount(row.getEmployeeCount());
                metadata.setLocation(row.getLocation());

                // Embedding Entity 생성
                float[] vectorArray = convertToFloatArray(row.getVectorList());
                validateVectorDimension(vectorArray, id);

                CompanyEmbeddingEntity embedding = new CompanyEmbeddingEntity();
                embedding.setId(id);
                embedding.setVector(new PGvector(vectorArray));

                metadataList.add(metadata);
                embeddingList.add(embedding);

                successCount++;
                lastSuccessUuid = id;

            } catch (Exception e) {
                failureCount++;
                UUID failedId = safeGetUuid(row.getId());

                log.warn("[ROW_PROCESSING_FAILED] ID: {} | Error: {}", failedId, e.getMessage());

                try {
                    String payloadJson = jsonMapper.writeValueAsString(row);
                    dlqService.saveToDlq(DOMAIN, failedId, e.getMessage(), payloadJson);
                } catch (Exception dlqError) {
                    log.error("[DLQ_SAVE_FAILED] ID: {} | Error: {}", failedId, dlqError.getMessage());
                }
            }
        }

        // 2. 성공한 데이터만 DB에 저장
        if (!metadataList.isEmpty()) {
            try {
                metadataRepository.upsertAll(metadataList);
                embeddingRepository.upsertAll(embeddingList);

                long totalElapsed = System.currentTimeMillis() - startTime;
                log.info("=== Company Chunk Processing Completed ===");
                log.info("Thread: {} | Total: {} | Success: {} | Failure: {} | Last UUID: {}",
                        threadName, chunkSize, successCount, failureCount, lastSuccessUuid);
                log.info("Processing Time: {}ms", totalElapsed);

            } catch (Exception e) {
                log.error("Error during batch upsert: {}", e.getMessage(), e);
                saveBatchToDlq(metadataList, e.getMessage());
                throw new RuntimeException("Batch upsert failed", e);
            }
        } else {
            log.warn("No successful rows to save. All rows failed.");
        }

        return new ChunkProcessingResult(chunkSize, successCount, failureCount, lastSuccessUuid, threadName);
    }

    private float[] convertToFloatArray(List<Float> vectorList) {
        float[] array = new float[vectorList.size()];
        for (int i = 0; i < vectorList.size(); i++) {
            array[i] = vectorList.get(i);
        }
        return array;
    }

    private void validateVectorDimension(float[] vector, UUID id) {
        int expectedDim = batchProperties.getDomainConfig(DOMAIN).getVectorDimension();
        if (vector.length != expectedDim) {
            String errorMsg = String.format(
                    "Vector dimension mismatch for UUID %s: expected=%d, actual=%d",
                    id, expectedDim, vector.length
            );
            log.error(errorMsg);
            throw new IllegalArgumentException(errorMsg);
        }
    }

    private UUID safeGetUuid(String id) {
        try {
            return UUID.fromString(id);
        } catch (Exception e) {
            log.error("Invalid UUID format: {}", id);
            return null;
        }
    }

    private void saveBatchToDlq(List<CompanyMetadataEntity> metadataList, String errorMessage) {
        log.warn("[BATCH_TO_DLQ] Saving {} failed metadata records to DLQ", metadataList.size());

        for (CompanyMetadataEntity metadata : metadataList) {
            try {
                String payloadJson = jsonMapper.writeValueAsString(metadata);
                dlqService.saveToDlq(DOMAIN, metadata.getId(), errorMessage, payloadJson);
            } catch (Exception e) {
                log.error("[DLQ_SAVE_FAILED] ID: {} | Error: {}", metadata.getId(), e.getMessage());
            }
        }
    }
}
```

**주요 특징:**
1. `ChunkProcessorInterface` 구현으로 Factory에 자동 등록
2. `getDomain()` 메서드로 "company" 도메인 식별
3. DLQ 처리 포함 (개별 row 실패, batch 실패 모두 처리)
4. Vector 차원 검증 (BatchProperties에서 설정 조회)
5. 상세 로깅 (스레드, 청크 사이즈, 성공/실패 통계)

### 5.2 ChunkProcessorFactory 자동 등록

새로운 ChunkProcessor를 작성하면 **Spring이 자동으로 Factory에 등록**합니다:

```java
// Spring이 자동으로 모든 ChunkProcessorInterface Bean을 주입
@Component
public class ChunkProcessorFactory {
    private final Map<String, ChunkProcessorInterface> processorMap;

    public ChunkProcessorFactory(List<ChunkProcessorInterface> processors) {
        // processors 리스트에 RecruitChunkProcessor, CandidateChunkProcessor,
        // CompanyChunkProcessor가 모두 포함됨
        this.processorMap = processors.stream()
                .collect(Collectors.toMap(
                        ChunkProcessorInterface::getDomain,
                        Function.identity()
                ));
    }
}
```

**별도 등록 코드 불필요** - `@Service` 어노테이션만 붙이면 자동 등록됩니다.

---

## 6. gRPC Proto 업데이트

### 6.1 Proto 파일 수정

**파일**: `embedding_stream.proto`

```protobuf
message EmbeddingStreamRequest {
    string domain = 1;  // "recruit", "candidate", "company"
    string checkpoint_uuid = 2;
}

message RowChunk {
    repeated RowData rows = 1;
}

message RowData {
    string uuid = 1;

    oneof data {
        RecruitData recruit_data = 2;
        CandidateData candidate_data = 3;
        CompanyData company_data = 4;  // 추가
    }

    repeated float vector = 5;
}

message CompanyData {
    string name = 1;
    string industry = 2;
    int32 employee_count = 3;
    string location = 4;
}
```

---

## 7. 테스트 작성

### 7.1 Repository 테스트

```java
@DataJpaTest
class CompanyMetadataRepositoryTest {

    @Autowired
    private CompanyMetadataRepository repository;

    @Test
    void upsert_should_insert_new_entity() {
        // Given
        CompanyMetadataEntity entity = CompanyMetadataEntity.builder()
                .id(UUID.randomUUID())
                .name("Test Company")
                .industry("IT")
                .employeeCount(100)
                .location("Seoul")
                .build();

        // When
        repository.upsertAll(List.of(entity));

        // Then
        Optional<CompanyMetadataEntity> found = repository.findById(entity.getId());
        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo("Test Company");
    }
}
```

### 7.2 통합 테스트

```java
@SpringBootTest
class CompanyDomainIntegrationTest {

    @Autowired
    private CompanyChunkProcessor processor;

    @Test
    void should_process_company_data_successfully() {
        // Given
        List<CompanyRowData> chunk = createTestChunk();

        // When
        processor.processChunk(chunk);

        // Then
        // 검증 로직
    }
}
```

---

## 8. 체크리스트

### 8.1 DB 마이그레이션
- [ ] V{n}__add_{domain}_schema.sql 작성
- [ ] V{n+1}__add_{domain}_domain_support.sql 작성
- [ ] 로컬 DB에서 마이그레이션 테스트
- [ ] flyway_schema_history 확인

### 8.2 Entity 및 Repository
- [ ] {Domain}MetadataEntity 작성
- [ ] {Domain}EmbeddingEntity 작성
- [ ] {Domain}MetadataRepository 작성
- [ ] {Domain}EmbeddingRepository 작성
- [ ] DlqEntity에 편의 메서드 추가 (`forCompany()`)
- [ ] CheckpointEntity에 편의 메서드 추가 (`forCompany()`)

### 8.3 서비스 레이어
- [ ] {Domain}ChunkProcessor 작성 (ChunkProcessorInterface 구현)
- [ ] `getDomain()` 메서드에서 도메인명 반환
- [ ] `@Service` 어노테이션 추가 (Factory 자동 등록)
- [ ] DLQ 처리 로직 포함
- [ ] Vector 차원 검증 로직 포함

### 8.4 gRPC
- [ ] Proto 파일에 {Domain}Data 추가
- [ ] Proto 재생성 (`./gradlew generateProto`)
- [ ] gRPC Client에 도메인 처리 추가

### 8.5 테스트
- [ ] Repository 단위 테스트
- [ ] Processor 단위 테스트
- [ ] 통합 테스트 (gRPC → DB)

### 8.6 문서화
- [ ] DB 스키마 가이드 업데이트
- [ ] ERD 다이어그램 업데이트
- [ ] API Server 팀에 스키마 변경 공지

---

## 9. 참조

- **DB 스키마 가이드**: `/Backend/docs/DB_스키마_가이드.md`
- **Flyway 마이그레이션 가이드**: `/Backend/docs/Flyway_마이그레이션_가이드.md`
- **gRPC 통신 가이드**: `/Backend/Batch-Server/docs/gRPC_통신_가이드.md`

---

### 8.7 설정 파일
- [ ] application.yml에 도메인별 설정 추가
```yaml
batch:
  embedding:
    domains:
      company:
        vector-dimension: 512
        table-prefix: company
```

---

**최종 수정일**: 2025-12-15
