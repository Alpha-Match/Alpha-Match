# 도메인 확장 가이드

**작성일**: 2025-12-17 (업데이트)
**대상**: Batch-Server
**목적**: 새 도메인 추가 시 체크리스트 및 절차

---

## 개요

Alpha-Match 프로젝트에 새 도메인을 추가하는 방법을 설명합니다. 현재 `recruit`, `candidate` 도메인이 구현되어 있으며, 동일한 패턴으로 확장 가능합니다.

### 도메인 추가 예시

이 가이드에서는 `company` 도메인을 추가하는 예시로 설명합니다.

---

## 1. 요구사항 정의

### 1.1 도메인 정보

| 항목 | 내용 |
|------|------|
| 도메인명 | company |
| 설명 | 회사 정보 |
| Vector 차원 | 512 |
| 주요 속성 | name, industry, employee_count, location |

### 1.2 테이블 설계

**company_metadata:**
- id (UUID, PK)
- name (VARCHAR)
- industry (VARCHAR)
- employee_count (INTEGER)
- location (VARCHAR)
- created_at (TIMESTAMP)
- updated_at (TIMESTAMP)

**company_embedding:**
- id (UUID, PK/FK)
- vector (VECTOR(512))
- updated_at (TIMESTAMP)

---

## 2. Flyway 마이그레이션 작성

### 2.1 도메인 스키마 추가

**파일**: `V6__add_company_schema.sql`

```sql
-- V6: Company 도메인 스키마 추가
-- 작성일: YYYY-MM-DD
-- 목적: 회사 정보 도메인 추가

-- 1. Company Metadata 테이블
CREATE TABLE company_metadata (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    industry VARCHAR(100),
    employee_count INTEGER CHECK(employee_count >= 0),
    location VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 2. Company Embedding 테이블 (512차원)
CREATE TABLE company_embedding (
    id UUID PRIMARY KEY REFERENCES company_metadata(id) ON DELETE CASCADE,
    vector VECTOR(512) NOT NULL,
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 3. 인덱스 생성
CREATE INDEX idx_company_metadata_updated_at ON company_metadata(updated_at);
CREATE INDEX idx_company_metadata_name ON company_metadata(name);
CREATE INDEX idx_company_metadata_industry ON company_metadata(industry);

-- pgvector IVFFlat 인덱스
CREATE INDEX company_embedding_ivfflat
ON company_embedding USING ivfflat (vector vector_l2_ops)
WITH (lists = 100);

-- 4. 트리거 생성 (updated_at 자동 갱신)
CREATE TRIGGER trigger_company_metadata_updated_at
BEFORE UPDATE ON company_metadata
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_company_embedding_updated_at
BEFORE UPDATE ON company_embedding
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- 5. 통계 정보 갱신
ANALYZE company_metadata;
ANALYZE company_embedding;
```

### 2.2 공통 테이블 업데이트

**파일**: `V7__add_company_domain_support.sql`

```sql
-- V7: Company 도메인 지원 추가
-- 작성일: YYYY-MM-DD
-- 목적: DLQ, Checkpoint에 company 도메인 추가

-- 1. DLQ 제약조건 업데이트
ALTER TABLE dlq DROP CONSTRAINT IF EXISTS chk_dlq_domain;
ALTER TABLE dlq ADD CONSTRAINT chk_dlq_domain
CHECK (domain IN ('recruit', 'candidate', 'company'));

-- 2. Checkpoint 제약조건 업데이트
ALTER TABLE checkpoint DROP CONSTRAINT IF EXISTS chk_checkpoint_domain;
ALTER TABLE checkpoint ADD CONSTRAINT chk_checkpoint_domain
CHECK (domain IN ('recruit', 'candidate', 'company'));

-- 3. Checkpoint 초기 레코드
INSERT INTO checkpoint (domain, last_processed_uuid, updated_at)
VALUES ('company', NULL, NOW())
ON CONFLICT (domain) DO NOTHING;

-- 4. 헬퍼 함수 업데이트 (get_domain_stats)
CREATE OR REPLACE FUNCTION get_domain_stats(domain_name VARCHAR)
RETURNS TABLE(
    metadata_count BIGINT,
    embedding_count BIGINT,
    dlq_count BIGINT,
    last_processed_uuid UUID,
    last_checkpoint_time TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        CASE
            WHEN domain_name = 'recruit' THEN (SELECT COUNT(*) FROM recruit_metadata)
            WHEN domain_name = 'candidate' THEN (SELECT COUNT(*) FROM candidate_metadata)
            WHEN domain_name = 'company' THEN (SELECT COUNT(*) FROM company_metadata)
            ELSE 0
        END AS metadata_count,
        CASE
            WHEN domain_name = 'recruit' THEN (SELECT COUNT(*) FROM recruit_embedding)
            WHEN domain_name = 'candidate' THEN (SELECT COUNT(*) FROM candidate_embedding)
            WHEN domain_name = 'company' THEN (SELECT COUNT(*) FROM company_embedding)
            ELSE 0
        END AS embedding_count,
        (SELECT COUNT(*) FROM dlq WHERE domain = domain_name) AS dlq_count,
        (SELECT last_processed_uuid FROM checkpoint WHERE domain = domain_name) AS last_processed_uuid,
        (SELECT updated_at FROM checkpoint WHERE domain = domain_name) AS last_checkpoint_time;
END;
$$ LANGUAGE plpgsql;

-- 5. 통계 뷰 업데이트 (v_all_domain_stats)
CREATE OR REPLACE VIEW v_all_domain_stats AS
SELECT
    'recruit' AS domain,
    (SELECT COUNT(*) FROM recruit_metadata) AS metadata_count,
    (SELECT COUNT(*) FROM recruit_embedding) AS embedding_count,
    (SELECT COUNT(*) FROM dlq WHERE domain = 'recruit') AS dlq_count,
    (SELECT last_processed_uuid FROM checkpoint WHERE domain = 'recruit') AS last_processed_uuid,
    (SELECT updated_at FROM checkpoint WHERE domain = 'recruit') AS last_checkpoint_time
UNION ALL
SELECT
    'candidate' AS domain,
    (SELECT COUNT(*) FROM candidate_metadata) AS metadata_count,
    (SELECT COUNT(*) FROM candidate_embedding) AS embedding_count,
    (SELECT COUNT(*) FROM dlq WHERE domain = 'candidate') AS dlq_count,
    (SELECT last_processed_uuid FROM checkpoint WHERE domain = 'candidate') AS last_processed_uuid,
    (SELECT updated_at FROM checkpoint WHERE domain = 'candidate') AS last_checkpoint_time
UNION ALL
SELECT
    'company' AS domain,
    (SELECT COUNT(*) FROM company_metadata) AS metadata_count,
    (SELECT COUNT(*) FROM company_embedding) AS embedding_count,
    (SELECT COUNT(*) FROM dlq WHERE domain = 'company') AS dlq_count,
    (SELECT last_processed_uuid FROM checkpoint WHERE domain = 'company') AS last_processed_uuid,
    (SELECT updated_at FROM checkpoint WHERE domain = 'company') AS last_checkpoint_time;
```

---

## 3. Entity 클래스 작성

### 3.1 디렉토리 구조

```
src/main/java/com/alpha/backend/domain/company/
├── CompanyMetadataEntity.java
├── CompanyEmbeddingEntity.java
├── CompanyMetadataRepository.java
└── CompanyEmbeddingRepository.java
```

### 3.2 Metadata Entity

**파일**: `CompanyMetadataEntity.java`

```java
package com.alpha.backend.domain.company;

import com.alpha.backend.domain.common.BaseMetadataEntity;
import jakarta.persistence.*;
import lombok.*;

import java.util.UUID;

@Entity
@Table(name = "company_metadata")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CompanyMetadataEntity extends BaseMetadataEntity {

    @Column(name = "name", nullable = false, length = 255)
    private String name;

    @Column(name = "industry", length = 100)
    private String industry;

    @Column(name = "employee_count")
    private Integer employeeCount;

    @Column(name = "location", length = 255)
    private String location;

    @Override
    public String getDomainType() {
        return "company";
    }

    public static class CompanyMetadataEntityBuilder {
        public CompanyMetadataEntityBuilder id(UUID id) {
            CompanyMetadataEntity entity = new CompanyMetadataEntity();
            entity.setId(id);
            return this;
        }
    }
}
```

### 3.3 Embedding Entity

**파일**: `CompanyEmbeddingEntity.java`

```java
package com.alpha.backend.domain.company;

import com.alpha.backend.domain.common.BaseEmbeddingEntity;
import com.pgvector.PGvector;
import jakarta.persistence.*;
import lombok.*;

import java.util.UUID;

@Entity
@Table(name = "company_embedding")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CompanyEmbeddingEntity extends BaseEmbeddingEntity {

    public static final int VECTOR_DIMENSION = 512;

    @Override
    public String getDomainType() {
        return "company";
    }

    @Override
    public int getVectorDimension() {
        return VECTOR_DIMENSION;
    }

    public static CompanyEmbeddingEntity fromFloatArray(UUID id, float[] vectorArray) {
        if (vectorArray.length != VECTOR_DIMENSION) {
            throw new IllegalArgumentException(
                    String.format("Vector dimension mismatch: expected %d, got %d",
                            VECTOR_DIMENSION, vectorArray.length)
            );
        }

        CompanyEmbeddingEntity entity = new CompanyEmbeddingEntity();
        entity.setId(id);
        entity.setVector(new PGvector(vectorArray));
        return entity;
    }
}
```

---

## 4. Repository 작성

### 4.1 Metadata Repository

**파일**: `CompanyMetadataRepository.java`

```java
package com.alpha.backend.domain.company;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

public interface CompanyMetadataRepository extends JpaRepository<CompanyMetadataEntity, UUID> {

    /**
     * Upsert (Bulk)
     */
    @Modifying
    @Query(value = """
        INSERT INTO company_metadata (id, name, industry, employee_count, location, created_at, updated_at)
        VALUES (:id, :name, :industry, :employeeCount, :location, :createdAt, :updatedAt)
        ON CONFLICT (id) DO UPDATE SET
            name = EXCLUDED.name,
            industry = EXCLUDED.industry,
            employee_count = EXCLUDED.employee_count,
            location = EXCLUDED.location,
            updated_at = EXCLUDED.updated_at
        """, nativeQuery = true)
    void upsert(
            @Param("id") UUID id,
            @Param("name") String name,
            @Param("industry") String industry,
            @Param("employeeCount") Integer employeeCount,
            @Param("location") String location,
            @Param("createdAt") LocalDateTime createdAt,
            @Param("updatedAt") LocalDateTime updatedAt
    );

    /**
     * Batch Upsert
     */
    default void upsertAll(List<CompanyMetadataEntity> entities) {
        for (CompanyMetadataEntity entity : entities) {
            upsert(
                    entity.getId(),
                    entity.getName(),
                    entity.getIndustry(),
                    entity.getEmployeeCount(),
                    entity.getLocation(),
                    entity.getCreatedAt(),
                    entity.getUpdatedAt()
            );
        }
    }
}
```

### 4.2 Embedding Repository

**파일**: `CompanyEmbeddingRepository.java`

```java
package com.alpha.backend.domain.company;

import com.pgvector.PGvector;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

public interface CompanyEmbeddingRepository extends JpaRepository<CompanyEmbeddingEntity, UUID> {

    /**
     * Upsert (Bulk)
     */
    @Modifying
    @Query(value = """
        INSERT INTO company_embedding (id, vector, updated_at)
        VALUES (:id, :vector, :updatedAt)
        ON CONFLICT (id) DO UPDATE SET
            vector = EXCLUDED.vector,
            updated_at = EXCLUDED.updated_at
        """, nativeQuery = true)
    void upsert(
            @Param("id") UUID id,
            @Param("vector") PGvector vector,
            @Param("updatedAt") LocalDateTime updatedAt
    );

    /**
     * Batch Upsert
     */
    default void upsertAll(List<CompanyEmbeddingEntity> entities) {
        for (CompanyEmbeddingEntity entity : entities) {
            upsert(entity.getId(), entity.getVector(), entity.getUpdatedAt());
        }
    }
}
```

---

## 5. Spring Batch 컴포넌트 작성

### 5.1 ItemReader 구현

**DomainItemReader를 상속하여 gRPC Stream 수신:**

**파일**: `CompanyItemReader.java`

```java
@Component
public class CompanyItemReader extends DomainItemReader<CompanyRow> {

    private final EmbeddingGrpcClient grpcClient;

    @Override
    protected Flux<CompanyRow> createStream(UUID lastProcessedUuid) {
        int chunkSize = batchProperties.getChunkSize();

        return grpcClient.streamEmbeddings(lastProcessedUuid, chunkSize)
            .flatMapIterable(RowChunk::getRowsList)
            .map(row -> row.getCompanyChunk())
            .filter(Objects::nonNull);
    }
}
```

**DomainItemReader 추상 클래스** (참고):
```java
public abstract class DomainItemReader<T> implements ItemReader<T> {
    private final BlockingQueue<T> queue = new LinkedBlockingQueue<>(1000);
    private volatile boolean streamCompleted = false;

    @PostConstruct
    public void init() {
        UUID lastProcessedUuid = getLastCheckpoint();
        createStream(lastProcessedUuid)
            .doOnNext(queue::offer)
            .doOnComplete(() -> streamCompleted = true)
            .subscribeOn(Schedulers.boundedElastic())
            .subscribe();
    }

    @Override
    public T read() throws Exception {
        T item = queue.poll(100, TimeUnit.MILLISECONDS);
        if (item == null && streamCompleted && queue.isEmpty()) {
            return null;
        }
        return item;
    }

    protected abstract Flux<T> createStream(UUID lastProcessedUuid);
}
```

### 5.2 ItemProcessor 구현

**DomainItemProcessor를 상속하여 Proto → Entity 변환:**

**파일**: `CompanyItemProcessor.java`

```java
@Component
public class CompanyItemProcessor
        extends DomainItemProcessor<CompanyRow, CompanyMetadataEntity, CompanyEmbeddingEntity> {

    @Override
    public DomainItem<CompanyMetadataEntity, CompanyEmbeddingEntity> process(CompanyRow item) {
        UUID id = UUID.fromString(item.getId());

        // Metadata Entity
        CompanyMetadataEntity metadata = new CompanyMetadataEntity();
        metadata.setId(id);
        metadata.setName(item.getName());
        metadata.setIndustry(item.getIndustry());
        metadata.setEmployeeCount(item.getEmployeeCount());
        metadata.setLocation(item.getLocation());

        // Embedding Entity
        float[] vectorArray = convertToFloatArray(item.getVectorList());
        validateVectorDimension(vectorArray, id, "company");

        CompanyEmbeddingEntity embedding = CompanyEmbeddingEntity.fromFloatArray(id, vectorArray);

        return new DomainItem<>(metadata, embedding);
    }
}
```

### 5.3 ItemWriter 사용

ItemWriter는 Generic한 `DomainItemWriter`를 재사용합니다. 별도 구현 불필요.

### 5.4 DomainJobFactory에 Job 추가

**파일**: `DomainJobFactory.java` (기존 파일 수정)

```java
@Component
public class DomainJobFactory {

    // 기존 코드...

    @Autowired
    private CompanyItemReader companyItemReader;

    @Autowired
    private CompanyItemProcessor companyItemProcessor;

    public Job createJob(String domain) {
        return switch (domain.toLowerCase()) {
            case "recruit" -> createRecruitJob();
            case "candidate" -> createCandidateJob();
            case "company" -> createCompanyJob();  // 추가
            default -> throw new IllegalArgumentException("Unsupported domain: " + domain);
        };
    }

    private Job createCompanyJob() {
        return new JobBuilder("companyEmbeddingProcessingJob", jobRepository)
                .listener(embeddingJobListener)
                .start(createCompanyStep())
                .build();
    }

    private Step createCompanyStep() {
        int chunkSize = batchProperties.getChunkSize();

        DomainItemWriter<CompanyMetadataEntity, CompanyEmbeddingEntity> writer =
            new DomainItemWriter<>(
                "company",
                companyMetadataRepository,
                companyEmbeddingRepository,
                companyMetadataRepository::upsertAll,
                companyEmbeddingRepository::upsertAll,
                dlqService
            );

        return new StepBuilder("companyEmbeddingStep", jobRepository)
                .<CompanyRow, DomainItem<CompanyMetadataEntity, CompanyEmbeddingEntity>>chunk(chunkSize, transactionManager)
                .reader(companyItemReader)
                .processor(companyItemProcessor)
                .writer(writer)
                .faultTolerant()
                .skip(Exception.class)
                .skipLimit(100)
                .listener(embeddingStepListener)
                .build();
    }
}
```

### 5.5 BatchJobConfig에 Job Bean 등록

**파일**: `BatchJobConfig.java` (기존 파일 수정)

```java
@Configuration
public class BatchJobConfig {

    private final DomainJobFactory domainJobFactory;

    @Bean
    public Job companyEmbeddingProcessingJob() {
        return domainJobFactory.createJob("company");
    }
}
```

### 5.6 Quartz Scheduler 설정 (선택)

**파일**: `BatchSchedulerConfig.java` (기존 파일 수정)

```java
@Bean
public JobDetail companyEmbeddingJobDetail() {
    return JobBuilder.newJob(CompanyEmbeddingQuartzJob.class)
            .withIdentity("companyEmbeddingJobDetail", "embedding")
            .storeDurably()
            .requestRecovery()
            .build();
}

@Bean
public Trigger companyEmbeddingTrigger(JobDetail companyEmbeddingJobDetail) {
    return TriggerBuilder.newTrigger()
            .forJob(companyEmbeddingJobDetail)
            .withSchedule(CronScheduleBuilder.cronSchedule(companyCronExpression)
                    .inTimeZone(TimeZone.getTimeZone("Asia/Seoul"))
                    .withMisfireHandlingInstructionDoNothing())
            .build();
}

public static class CompanyEmbeddingQuartzJob extends QuartzJobBean {
    @Override
    protected void executeInternal(JobExecutionContext context) {
        Job job = jobRegistry.getJob("companyEmbeddingProcessingJob");
        JobParameters jobParameters = new JobParametersBuilder()
                .addString("timestamp", new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").format(new Date()))
                .toJobParameters();
        JobExecution execution = jobOperator.start(job, jobParameters);
    }
}
```

---

## 6. gRPC Proto 업데이트

### 6.1 Proto 파일 수정

**파일**: `embedding_stream.proto`

```protobuf
message EmbeddingStreamRequest {
    string domain = 1;  // "recruit", "candidate", "company"
    string checkpoint_uuid = 2;
}

message RowChunk {
    repeated RowData rows = 1;
}

message RowData {
    string uuid = 1;

    oneof data {
        RecruitData recruit_data = 2;
        CandidateData candidate_data = 3;
        CompanyData company_data = 4;  // 추가
    }

    repeated float vector = 5;
}

message CompanyData {
    string name = 1;
    string industry = 2;
    int32 employee_count = 3;
    string location = 4;
}
```

---

## 7. 테스트 작성

### 7.1 Repository 테스트

```java
@DataJpaTest
class CompanyMetadataRepositoryTest {

    @Autowired
    private CompanyMetadataRepository repository;

    @Test
    void upsert_should_insert_new_entity() {
        // Given
        CompanyMetadataEntity entity = CompanyMetadataEntity.builder()
                .id(UUID.randomUUID())
                .name("Test Company")
                .industry("IT")
                .employeeCount(100)
                .location("Seoul")
                .build();

        // When
        repository.upsertAll(List.of(entity));

        // Then
        Optional<CompanyMetadataEntity> found = repository.findById(entity.getId());
        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo("Test Company");
    }
}
```

### 7.2 통합 테스트

```java
@SpringBootTest
class CompanyDomainIntegrationTest {

    @Autowired
    private CompanyChunkProcessor processor;

    @Test
    void should_process_company_data_successfully() {
        // Given
        List<CompanyRowData> chunk = createTestChunk();

        // When
        processor.processChunk(chunk);

        // Then
        // 검증 로직
    }
}
```

---

## 8. 체크리스트

### 8.1 DB 마이그레이션
- [ ] V{n}__add_{domain}_schema.sql 작성
- [ ] V{n+1}__add_{domain}_domain_support.sql 작성
- [ ] 로컬 DB에서 마이그레이션 테스트
- [ ] flyway_schema_history 확인

### 8.2 Entity 및 Repository
- [ ] {Domain}MetadataEntity 작성
- [ ] {Domain}EmbeddingEntity 작성
- [ ] {Domain}MetadataRepository 작성
- [ ] {Domain}EmbeddingRepository 작성
- [ ] DlqEntity에 편의 메서드 추가 (`forCompany()`)
- [ ] CheckpointEntity에 편의 메서드 추가 (`forCompany()`)

### 8.3 Spring Batch 컴포넌트
- [ ] {Domain}ItemReader 작성 (DomainItemReader 상속)
- [ ] {Domain}ItemProcessor 작성 (DomainItemProcessor 상속)
- [ ] DomainJobFactory에 Job 추가 (`create{Domain}Job()` 메서드)
- [ ] BatchJobConfig에 Job Bean 등록
- [ ] Vector 차원 검증 로직 포함 (ItemProcessor 내)

### 8.4 gRPC
- [ ] Proto 파일에 {Domain}Data 추가
- [ ] Proto 재생성 (`./gradlew generateProto`)
- [ ] gRPC Client에 도메인 처리 추가

### 8.5 테스트
- [ ] Repository 단위 테스트
- [ ] Processor 단위 테스트
- [ ] 통합 테스트 (gRPC → DB)

### 8.6 Quartz Scheduler 설정 (선택)
- [ ] BatchSchedulerConfig에 JobDetail 추가
- [ ] BatchSchedulerConfig에 Trigger 추가
- [ ] QuartzJobBean 구현 클래스 추가
- [ ] application.yml에 Cron 표현식 설정

### 8.7 application.yml 설정
- [ ] 도메인별 설정 추가
```yaml
batch:
  embedding:
    domains:
      company:
        vector-dimension: 512
        table-prefix: company
  scheduler:
    jobs:
      company:
        cron: "0 0 3 * * ?"  # 매일 새벽 3시
        enabled: true
```

### 8.8 문서화
- [ ] DB 스키마 가이드 업데이트 (`/Backend/docs/table_specification.md`)
- [ ] ERD 다이어그램 업데이트
- [ ] API Server 팀에 스키마 변경 공지
- [ ] CLAUDE.md "구현 예정" 섹션 업데이트

---

## 9. 참조

- **Spring Batch 개발 가이드**: `/docs/Spring_Batch_개발_가이드.md` ⭐
- **동시성 제어 가이드**: `/docs/동시성_제어_가이드.md`
- **Backend 공통 문서**:
  - DB 스키마 가이드: `/Backend/docs/DB_스키마_가이드.md`
  - 테이블 명세서: `/Backend/docs/table_specification.md`
  - Flyway 마이그레이션 가이드: `/Backend/docs/Flyway_마이그레이션_가이드.md`

---

**최종 수정일**: 2025-12-17
