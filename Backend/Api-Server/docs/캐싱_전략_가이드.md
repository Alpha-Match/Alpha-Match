# ìºì‹± ì „ëµ ê°€ì´ë“œ

**ì‘ì„±ì¼**: 2025-12-23
**ëŒ€ìƒ**: Api-Server
**ëª©ì **: Caffeine + Redis ë©€í‹° ë ˆì´ì–´ ìºì‹± ì„¤ê³„ ë° êµ¬í˜„

---

## ğŸ“‹ ê°œìš”

Api-ServerëŠ” **2ë‹¨ê³„ ìºì‹± ì „ëµ**ì„ ì‚¬ìš©í•˜ì—¬ ì¡°íšŒ ì„±ëŠ¥ì„ ìµœì í™”í•©ë‹ˆë‹¤.
- **L1 Cache (Caffeine)**: In-memory, ë¹ ë¥¸ ì‘ë‹µ
- **L2 Cache (Redis)**: ë¶„ì‚° ìºì‹±, ì—¬ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ ê³µìœ 

### ìºì‹± í”Œë¡œìš°

```
Request
  â†“
L1 Cache (Caffeine) - 10ì´ˆ TTL
  â”œâ”€ Hit â†’ Return
  â””â”€ Miss â†“
       L2 Cache (Redis) - 10ë¶„ TTL
         â”œâ”€ Hit â†’ L1 ì—…ë°ì´íŠ¸ â†’ Return
         â””â”€ Miss â†“
              DB (PostgreSQL)
                â†“
              L2 ì—…ë°ì´íŠ¸ â†’ L1 ì—…ë°ì´íŠ¸ â†’ Return
```

---

## ğŸ—ï¸ ì•„í‚¤í…ì²˜

### 1. CacheConfig

```java
@Configuration
@EnableCaching
public class CacheConfig {

    /**
     * L1 Cache: Caffeine (In-memory)
     */
    @Bean
    public CacheManager caffeineCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager(
                "recruits", "candidates", "skills"
        );

        cacheManager.setCaffeine(
                Caffeine.newBuilder()
                        .maximumSize(10_000)
                        .expireAfterWrite(10, TimeUnit.SECONDS)
                        .recordStats()
        );

        return cacheManager;
    }

    /**
     * L2 Cache: Redis (Distributed)
     */
    @Bean
    public ReactiveRedisTemplate<String, String> reactiveRedisTemplate(
            ReactiveRedisConnectionFactory connectionFactory
    ) {
        RedisSerializer<String> serializer = new StringRedisSerializer();
        RedisSerializationContext<String, String> context =
                RedisSerializationContext.<String, String>newSerializationContext(serializer)
                        .key(serializer)
                        .value(serializer)
                        .hashKey(serializer)
                        .hashValue(serializer)
                        .build();

        return new ReactiveRedisTemplate<>(connectionFactory, context);
    }
}
```

---

## ğŸ”§ CacheService êµ¬í˜„

### Multi-Layer CacheService

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class CacheService {

    private final CacheManager caffeineCacheManager;
    private final ReactiveRedisTemplate<String, String> redisTemplate;
    private final ObjectMapper objectMapper;

    private static final int L1_TTL_SECONDS = 10;
    private static final int L2_TTL_SECONDS = 600; // 10ë¶„

    /**
     * ìºì‹œ ì¡°íšŒ (L1 â†’ L2 â†’ DB)
     */
    public <T> Mono<T> get(String key, Class<T> type) {
        // 1. L1 Cache í™•ì¸
        T l1Value = getFromL1(key, type);
        if (l1Value != null) {
            log.debug("L1 Cache Hit: {}", key);
            return Mono.just(l1Value);
        }

        // 2. L2 Cache í™•ì¸
        return getFromL2(key, type)
                .doOnNext(value -> {
                    log.debug("L2 Cache Hit: {}", key);
                    putToL1(key, value);
                })
                .switchIfEmpty(Mono.defer(() -> {
                    log.debug("Cache Miss: {}", key);
                    return Mono.empty();
                }));
    }

    /**
     * ìºì‹œ ì €ì¥ (L1 + L2)
     */
    public <T> Mono<Void> set(String key, T value, int ttlSeconds) {
        putToL1(key, value);
        return putToL2(key, value, ttlSeconds);
    }

    /**
     * ìºì‹œ ë¬´íš¨í™” (L1 + L2)
     */
    public Mono<Void> evict(String key) {
        evictFromL1(key);
        return evictFromL2(key);
    }

    /**
     * íŒ¨í„´ ê¸°ë°˜ ìºì‹œ ë¬´íš¨í™”
     */
    public Mono<Void> evictByPattern(String pattern) {
        evictFromL1ByPattern(pattern);
        return evictFromL2ByPattern(pattern);
    }

    // ===== L1 Cache (Caffeine) =====

    private <T> T getFromL1(String key, Class<T> type) {
        Cache cache = caffeineCacheManager.getCache("default");
        if (cache == null) return null;

        Cache.ValueWrapper wrapper = cache.get(key);
        if (wrapper == null) return null;

        return type.cast(wrapper.get());
    }

    private <T> void putToL1(String key, T value) {
        Cache cache = caffeineCacheManager.getCache("default");
        if (cache != null) {
            cache.put(key, value);
        }
    }

    private void evictFromL1(String key) {
        Cache cache = caffeineCacheManager.getCache("default");
        if (cache != null) {
            cache.evict(key);
        }
    }

    private void evictFromL1ByPattern(String pattern) {
        // Caffeineì€ íŒ¨í„´ ê¸°ë°˜ ì‚­ì œ ì§€ì› ì•ˆ í•¨ â†’ ì „ì²´ ìºì‹œ í´ë¦¬ì–´
        Cache cache = caffeineCacheManager.getCache("default");
        if (cache != null) {
            cache.clear();
        }
    }

    // ===== L2 Cache (Redis) =====

    private <T> Mono<T> getFromL2(String key, Class<T> type) {
        return redisTemplate.opsForValue()
                .get(key)
                .map(json -> {
                    try {
                        return objectMapper.readValue(json, type);
                    } catch (Exception e) {
                        log.error("Redis deserialization error: {}", e.getMessage());
                        return null;
                    }
                });
    }

    private <T> Mono<Void> putToL2(String key, T value, int ttlSeconds) {
        try {
            String json = objectMapper.writeValueAsString(value);
            return redisTemplate.opsForValue()
                    .set(key, json, Duration.ofSeconds(ttlSeconds))
                    .then();
        } catch (Exception e) {
            log.error("Redis serialization error: {}", e.getMessage());
            return Mono.empty();
        }
    }

    private Mono<Void> evictFromL2(String key) {
        return redisTemplate.delete(key).then();
    }

    private Mono<Void> evictFromL2ByPattern(String pattern) {
        return redisTemplate.keys(pattern + "*")
                .flatMap(redisTemplate::delete)
                .then();
    }
}
```

---

## ğŸ”„ ìºì‹œ ë¬´íš¨í™” ì „ëµ

### 1. gRPC Serverë¡œ ìºì‹œ ë¬´íš¨í™” ìˆ˜ì‹ 

**Batch Server â†’ Api Server í†µì‹ **

```java
@GrpcService
@RequiredArgsConstructor
@Slf4j
public class CacheInvalidateServiceImpl extends CacheServiceGrpc.CacheServiceImplBase {

    private final CacheInvalidationService cacheInvalidationService;
    private final AtomicBoolean invalidating = new AtomicBoolean(false);

    @Override
    public void invalidateCache(
            CacheInvalidateRequest request,
            StreamObserver<CacheInvalidateResponse> responseObserver
    ) {
        // ë™ì‹œì„± ì œì–´ (CAS)
        if (!invalidating.compareAndSet(false, true)) {
            log.warn("Cache invalidation already in progress");
            responseObserver.onNext(
                    CacheInvalidateResponse.newBuilder()
                            .setSuccess(false)
                            .build()
            );
            responseObserver.onCompleted();
            return;
        }

        try {
            String target = request.getTarget();
            log.info("Invalidating cache for target: {}", target);

            cacheInvalidationService.invalidateCache(target)
                    .doOnSuccess(v -> log.info("Cache invalidated successfully: {}", target))
                    .doOnError(e -> log.error("Cache invalidation failed: {}", e.getMessage()))
                    .block(); // gRPCëŠ” blocking í—ˆìš©

            responseObserver.onNext(
                    CacheInvalidateResponse.newBuilder()
                            .setSuccess(true)
                            .build()
            );
            responseObserver.onCompleted();

        } finally {
            invalidating.set(false);
        }
    }
}
```

### 2. CacheInvalidationService

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class CacheInvalidationService {

    private final CacheService cacheService;

    /**
     * ë„ë©”ì¸ë³„ ìºì‹œ ë¬´íš¨í™”
     */
    public Mono<Void> invalidateCache(String target) {
        return switch (target.toLowerCase()) {
            case "recruit" -> cacheService.evictByPattern("recruit:*");
            case "candidate" -> cacheService.evictByPattern("candidate:*");
            case "skill" -> cacheService.evictByPattern("skill:*");
            case "all" -> invalidateAll();
            default -> {
                log.warn("Unknown cache target: {}", target);
                yield Mono.empty();
            }
        };
    }

    private Mono<Void> invalidateAll() {
        return Mono.when(
                cacheService.evictByPattern("recruit:*"),
                cacheService.evictByPattern("candidate:*"),
                cacheService.evictByPattern("skill:*")
        );
    }
}
```

---

## ğŸ“Š ìºì‹œ í‚¤ ì„¤ê³„

### í‚¤ ë„¤ì´ë° ì»¨ë²¤ì…˜

```
{domain}:{id}                  # ë‹¨ê±´ ì¡°íšŒ
{domain}:list:{offset}:{limit} # ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
{domain}:search:{hash}         # ê²€ìƒ‰ ê²°ê³¼
```

### ì˜ˆì‹œ

```java
// Recruit ë‹¨ê±´
String key = "recruit:" + recruitId;

// Recruit ë¦¬ìŠ¤íŠ¸
String key = String.format("recruit:list:%d:%d", offset, limit);

// Recruit ê²€ìƒ‰ (ìŠ¤í‚¬ ê¸°ë°˜)
String hash = DigestUtils.md5Hex(skills.toString());
String key = "recruit:search:" + hash;
```

---

## ğŸ§ª ìºì‹œ ëª¨ë‹ˆí„°ë§

### CacheStatsService

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class CacheStatsService {

    private final CacheManager caffeineCacheManager;

    @Scheduled(fixedRate = 60000) // 1ë¶„ë§ˆë‹¤
    public void logCacheStats() {
        Cache cache = caffeineCacheManager.getCache("default");
        if (cache instanceof CaffeineCache caffeineCache) {
            com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache =
                    caffeineCache.getNativeCache();

            CacheStats stats = nativeCache.stats();
            log.info("L1 Cache Stats - Hit Rate: {}, Evictions: {}, Size: {}",
                    String.format("%.2f%%", stats.hitRate() * 100),
                    stats.evictionCount(),
                    nativeCache.estimatedSize()
            );
        }
    }
}
```

---

## âš™ï¸ ì„¤ì • (application.yml)

```yaml
spring:
  # Redis ì„¤ì •
  data:
    redis:
      host: localhost
      port: 6379
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5

  # Cache ì„¤ì •
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=10000,expireAfterWrite=10s

# ì»¤ìŠ¤í…€ ìºì‹œ ì„¤ì •
cache:
  l1:
    ttl: 10 # seconds
    max-size: 10000
  l2:
    ttl: 600 # seconds (10ë¶„)
```

---

## ğŸ”’ ë™ì‹œì„± ì œì–´

### Monitor Lock íŒ¨í„´

```java
private final Object cacheLock = new Object();

public Mono<Void> invalidateCache(String target) {
    return Mono.fromCallable(() -> {
        synchronized (cacheLock) {
            // ìºì‹œ ë¬´íš¨í™” ë¡œì§
            cacheService.evictByPattern(target + ":*").block();
            return null;
        }
    });
}
```

### ReentrantLock íŒ¨í„´ (Virtual Thread ì¹œí™”ì )

```java
private final ReentrantLock cacheLock = new ReentrantLock();

public Mono<Void> invalidateCache(String target) {
    return Mono.fromCallable(() -> {
        cacheLock.lock();
        try {
            cacheService.evictByPattern(target + ":*").block();
            return null;
        } finally {
            cacheLock.unlock();
        }
    });
}
```

---

## ğŸ“ˆ ì„±ëŠ¥ ìµœì í™”

### 1. Cache Aside íŒ¨í„´

```java
public Mono<Recruit> findById(UUID id) {
    String key = "recruit:" + id;

    return cacheService.get(key, Recruit.class)
            .switchIfEmpty(
                    recruitRepository.findById(id)
                            .flatMap(recruit ->
                                    cacheService.set(key, recruit, 600)
                                            .thenReturn(recruit)
                            )
            );
}
```

### 2. Cache Warming (ì‚¬ì „ ë¡œë”©)

```java
@EventListener(ApplicationReadyEvent.class)
public void warmUpCache() {
    log.info("Warming up cache...");

    recruitRepository.findPopular(100)
            .flatMap(recruit ->
                    cacheService.set("recruit:" + recruit.getId(), recruit, 600)
            )
            .subscribe();
}
```

---

## ğŸ“š ì°¸ê³  ë¬¸ì„œ

- **GraphQL API ê°œë°œ**: `GraphQL_API_ê°œë°œ_ê°€ì´ë“œ.md`
- **Reactive í”„ë¡œê·¸ë˜ë°**: `Reactive_í”„ë¡œê·¸ë˜ë°_ê°€ì´ë“œ.md`
- **ë™ì‹œì„± ì œì–´**: `/Backend/Batch-Server/docs/ë™ì‹œì„±_ì œì–´.md`

---

**ìµœì¢… ìˆ˜ì •ì¼**: 2025-12-23
